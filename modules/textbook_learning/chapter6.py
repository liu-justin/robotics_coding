import chapter3 as ch3 
import chapter4 as ch4 
import chapter5 as ch5 

import math
import numpy as np

def IK_body(Blist, M, T, thetalist0, e_omega, e_v):
    """uses iterative Netwon Raphson to calculate inverse kinematics

    Args:
        Blist : list of joint screws expressed in the end effector frame scriptB
        M : end effector home configuration
        T : desired end effector configuration (T_sd)
        thetalist0: initial guess
        e_omega : omega error tolerance for stoppage
        e_v : linear velocity error tolerance for stoppage
    """
    thetaList = thetalist0
    # finds transf matrix of current guess T_sb
    T_sb = ch4.forward_kinematics_in_body(M, Blist, thetaList)
    T_bs = ch3.transf_matrix_inverse(T_sb)
    # finds the se3 for the transf matrix T_bd (transformation from current guess to answer)
    (scriptV_b_bracketed, theta) = ch3.transf_matrix_to_se3(T_bs @ T)
    scriptV_b_exp6 = ch3.se3_to_vector6(scriptV_b_bracketed*theta)
    # these velocities are required to get from T_sb (current) to T_sd (target)
    # - want to bring these to zero
    omega = scriptV_b_exp6[0:3]
    v = scriptV_b_exp6[3:6]

    counter = 0
    print(ch3.magnitude(omega))
    print(ch3.magnitude(v))
    while((ch3.magnitude(omega) > e_omega or ch3.magnitude(v) > e_v) and counter < 25):
        # use the jacobian body in chapter 5 to see what velocities can be generated by each angle velocity
        #- uses this stupid pseudo inverse thing that i missed
        jacobian_b = np.linalg.pinv(ch5.jacobian_body(Blist, thetaList))
        # multiplying the jacobian by the twist gives an angle to add to
        thetaListaddition = np.dot(jacobian_b, np.reshape(scriptV_b_exp6, (-1,1)))
        # add said angle
        thetaList = [sum(i) for i in zip(thetaList,thetaListaddition.flatten().tolist())]
        # recalculate current transf matrix, scriptV, screw, omega, and v
        T_sb = ch4.forward_kinematics_in_body(M, Blist, thetaList)
        T_bs = ch3.transf_matrix_inverse(T_sb)
        (scriptV_b_bracketed, theta) = ch3.transf_matrix_to_se3(T_bs @ T)
        scriptV_b_exp6 = ch3.se3_to_vector6(scriptV_b_bracketed*theta)
        omega = scriptV_b_exp6[0:3]
        v = scriptV_b_exp6[3:6]

        counter += 1


    return (thetaList, counter < 25)